# cmake/build_system/package_configuration.cmake
# ... (top part of file is unchanged from Milestone 2) ...
# ==============================================================================
#           PHASE 1: PACKAGE CONFIGURATION
# ==============================================================================
function(configure_discovered_packages)
    set(package_paths ${ARGN})
    # Use the new state function to set package paths
    kis_state_set_all_package_paths("${package_paths}")
    
    kis_get_current_variant_name(current_variant)
    kis_get_variant_abi_group("${current_variant}" current_abi_group)
    message(STATUS "Configuring packages for variant: ${current_variant} (ABI: ${current_abi_group})")
    set(base_variant "release")
    if(current_abi_group STREQUAL "DEBUG")
        set(base_variant "debug")
    endif()

    foreach(package_path ${package_paths})
        kis_get_package_name_from_path("${package_path}" package_name)
        set(should_build TRUE)
        set(should_import FALSE)
        set(skip_reason "")
        kis_read_package_manifest_json("${package_path}")
        # ... (all the logic for should_build/should_import is unchanged) ...
        if(DEFINED MANIFEST_FEATURES)
            set(should_build FALSE)
            foreach(required_feature ${MANIFEST_FEATURES})
                if(required_feature IN_LIST KIS_ACTIVE_FEATURES)
                    set(should_build TRUE)
                    break()
                endif()
            endforeach()
            if(NOT should_build)
                set(skip_reason "requires features [${MANIFEST_FEATURES}], active: [${KIS_ACTIVE_FEATURES}]")
            endif()
        endif()
        if(NOT DEFINED MANIFEST_ABI_VARIANT)
            set(MANIFEST_ABI_VARIANT "PER_CONFIG")
        endif()
        if(should_build)
            if(MANIFEST_ABI_VARIANT STREQUAL "ABI_INVARIANT")
                if(NOT current_variant STREQUAL "release" AND NOT current_variant STREQUAL "debug")
                    set(should_build FALSE)
                    set(should_import TRUE)
                    set(skip_reason "ABI_INVARIANT package only builds in release/debug variants")
                endif()
            elseif(MANIFEST_ABI_VARIANT STREQUAL "PER_CONFIG")
                if(DEFINED MANIFEST_SUPPORTED_VARIANTS)
                    set(supported_variants "${MANIFEST_SUPPORTED_VARIANTS}")
                else()
                    set(supported_variants "release;debug")
                endif()
                if(NOT "release" IN_LIST supported_variants)
                    list(APPEND supported_variants "release")
                endif()
                if(NOT "debug" IN_LIST supported_variants)
                    list(APPEND supported_variants "debug")
                endif()
                if(NOT current_variant IN_LIST supported_variants)
                    set(should_build FALSE)
                    set(should_import TRUE)
                    set(skip_reason "PER_CONFIG package does not support variant '${current_variant}' (supports: ${supported_variants})")
                endif()
            endif()
        endif()
        
        if(should_build)
            # Add KIS dependencies to the central state
            if(DEFINED MANIFEST_KIS_DEPENDENCIES)
                string(JSON num_deps LENGTH "${MANIFEST_KIS_DEPENDENCIES}")
                if(num_deps GREATER 0)
                    math(EXPR last_idx "${num_deps} - 1")
                    foreach(i RANGE ${last_idx})
                        string(JSON dep_obj GET "${MANIFEST_KIS_DEPENDENCIES}" ${i})
                        kis_state_add_kis_dependency("${dep_obj}")
                    endforeach()
                endif()
            endif()
            # Handle TPL dependencies using the refactored function
            if(DEFINED MANIFEST_TPL_DEPENDENCIES)
                kis_handle_third_party_dependencies("${package_name}" "${MANIFEST_TPL_DEPENDENCIES}")
            endif()
        endif()
        
        if(NOT should_build)
            if(should_import)
                kis_message_verbose("Package '${package_name}': ${skip_reason}")
                message(STATUS "  -> Importing ${package_name} from ${base_variant} variant")
                _kis_create_imported_package_target("${package_name}" "${package_path}" "${base_variant}")
            else()
                kis_message_verbose("Skipping package '${package_name}': ${skip_reason}")
                if(NOT TARGET ${package_name})
                    add_library(${package_name} INTERFACE IMPORTED GLOBAL)
                    message(STATUS "  -> Created stub target for skipped package: ${package_name}")
                endif()
                if(NOT TARGET kis::${package_name})
                    add_library(kis::${package_name} ALIAS ${package_name})
                endif()
            endif()
        else()
            message(STATUS "Configuring package: ${package_name}")
            kis_profile_begin("${package_name}" "configure")
            if(DEFINED MANIFEST_TYPE)
                set(pkg_platform "common")
                if(DEFINED MANIFEST_PLATFORMS) 
                list(GET MANIFEST_PLATFORMS 0 pkg_platform) 
                endif()
                kis_graph_add_node("${package_name}" "${MANIFEST_TYPE}" "${pkg_platform}")
            endif()
            set(source_dir ${package_path})
            set(binary_dir "${CMAKE_BINARY_DIR}/_deps/${package_name}-build")
            add_subdirectory(${source_dir} ${binary_dir})
            kis_profile_end("${package_name}" "configure")
        endif()
    endforeach()
endfunction()

# ==============================================================================
#           PHASE 2: DEPENDENCY LINKING
# ==============================================================================
function(link_all_package_dependencies)
    set(all_packages ${ARGN})
    foreach(package_path ${all_packages})
        kis_get_package_name_from_path("${package_path}" package_name)
        if(TARGET ${package_name})
            # Check for pending links using the new CACHE variable pattern
            set(cache_var "_KIS_CTX_PENDING_LINKS_${package_name}")
            if(DEFINED CACHE{${cache_var}})
                kis_execute_deferred_links(${package_name})
            else()
                kis_message_verbose("No deferred links for '${package_name}' (imported or no dependencies)")
            endif()
        else()
            kis_message_verbose("Skipping deferred links for '${package_name}' (target does not exist)")
        endif()
    endforeach()
endfunction()