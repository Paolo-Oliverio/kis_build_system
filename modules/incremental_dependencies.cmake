# kis_build_system/modules/incremental_dependencies.cmake
#
# Smart incremental detection for third-party dependencies.
# Only re-fetches/re-builds dependencies when necessary.

# ==============================================================================
#           DEPENDENCY FINGERPRINTING
# ==============================================================================
function(kis_compute_dependency_fingerprint dep_name dep_args out_fingerprint_var)
    set(fingerprint_parts "")
    set(git_repo "")
    set(git_tag "")
    set(url "")
    set(url_hash "")
    list(LENGTH dep_args args_len)
    set(i 0)
    while(i LESS args_len)
        list(GET dep_args ${i} key)
        math(EXPR i "${i} + 1")
        
        if(key STREQUAL "GIT_REPOSITORY" AND i LESS args_len)
            list(GET dep_args ${i} git_repo)
            math(EXPR i "${i} + 1")
        elseif(key STREQUAL "GIT_TAG" AND i LESS args_len)
            list(GET dep_args ${i} git_tag)
            math(EXPR i "${i} + 1")
        elseif(key STREQUAL "GIT_COMMIT" AND i LESS args_len)
            list(GET dep_args ${i} git_tag) # Use commit as tag
            math(EXPR i "${i} + 1")
        elseif(key STREQUAL "URL" AND i LESS args_len)
            list(GET dep_args ${i} url)
            math(EXPR i "${i} + 1")
        elseif(key STREQUAL "URL_HASH" AND i LESS args_len)
            list(GET dep_args ${i} url_hash)
            math(EXPR i "${i} + 1")
        else()
            # This handles cases where a value is missing for a key
            # and prevents an infinite loop.
            math(EXPR i "${i} + 1")
        endif()
    endwhile()

    if(git_repo)
        list(APPEND fingerprint_parts "git:${git_repo}")
    endif()
    if(git_tag)
        list(APPEND fingerprint_parts "tag:${git_tag}")
    endif()
    if(url)
        list(APPEND fingerprint_parts "url:${url}")
    endif()
    if(url_hash)
        list(APPEND fingerprint_parts "hash:${url_hash}")
    endif()
    list(JOIN fingerprint_parts "|" final_fingerprint)
    set(${out_fingerprint_var} "${final_fingerprint}" PARENT_SCOPE)
endfunction()

function(kis_dependency_needs_fetch dep_name dep_args out_needs_fetch)
    if(KIS_FORCE_DEPENDENCY_REBUILD)
        set(${out_needs_fetch} TRUE PARENT_SCOPE)
        return()
    endif()
    if(NOT DEFINED FETCHCONTENT_BASE_DIR)
        set(FETCHCONTENT_BASE_DIR "${CMAKE_BINARY_DIR}/_deps")
    endif()
    set(source_dir "${FETCHCONTENT_BASE_DIR}/${dep_name}-src")
    
    list(FIND dep_args "SOURCE_DIR" source_dir_idx)
    if(source_dir_idx GREATER -1)
        math(EXPR value_idx "${source_dir_idx} + 1")
        list(GET dep_args ${value_idx} source_dir)
    endif()
    if(NOT EXISTS "${source_dir}")
        message(STATUS "[INCREMENTAL] '${dep_name}' not found - will fetch")
        set(${out_needs_fetch} TRUE PARENT_SCOPE)
        return()
    endif()
    kis_compute_dependency_fingerprint("${dep_name}" "${dep_args}" current_fingerprint)
    set(cache_var "KIS_DEP_FINGERPRINT_${dep_name}")
    if(DEFINED CACHE{${cache_var}})
        set(cached_fingerprint "${${cache_var}}")
        if("${current_fingerprint}" STREQUAL "${cached_fingerprint}")
            message(STATUS "[INCREMENTAL] Skipping '${dep_name}' (already populated)")
            set(${out_needs_fetch} FALSE PARENT_SCOPE)
            return()
        else()
            message(STATUS "[INCREMENTAL] Re-fetching '${dep_name}' (version/URL changed)")
        endif()
    else()
        message(STATUS "[INCREMENTAL] First fetch for '${dep_name}'")
    endif()
    set(${cache_var} "${current_fingerprint}" CACHE INTERNAL "Fingerprint for ${dep_name}")
    set(${out_needs_fetch} TRUE PARENT_SCOPE)
endfunction()

# ==============================================================================
#           SMART FETCHCONTENT WRAPPER
# ==============================================================================
function(kis_fetch_content_make_available_incremental dep_names_list)
    set(deps_to_fetch "")
    set(deps_to_load "")
    
    foreach(dep_name ${dep_names_list})
        get_property(dep_args GLOBAL PROPERTY KIS_TPL_DECLARED_${dep_name}_ARGS)
        kis_dependency_needs_fetch("${dep_name}" "${dep_args}" needs_fetch)
        if(needs_fetch)
            list(APPEND deps_to_fetch "${dep_name}")
        else()
            list(APPEND deps_to_load "${dep_name}")
        endif()
    endforeach()
    
    list(LENGTH deps_to_fetch fetch_count)
    list(LENGTH deps_to_load load_count)
    
    if(load_count GREATER 0 OR fetch_count GREATER 0)
        message(STATUS "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
        message(STATUS "Incremental Dependency Fetch")
        message(STATUS "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
        message(STATUS "  Dependencies to fetch:  ${fetch_count}")
        message(STATUS "  Dependencies to reuse:  ${load_count}")
        message(STATUS "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
    endif()
    
    if(deps_to_fetch)
        FetchContent_MakeAvailable(${deps_to_fetch})
    endif()
    
    if(deps_to_load)
        foreach(dep_name ${deps_to_load})
            get_property(dep_args GLOBAL PROPERTY KIS_TPL_DECLARED_${dep_name}_ARGS)
            if(NOT DEFINED FETCHCONTENT_BASE_DIR)
                set(FETCHCONTENT_BASE_DIR "${CMAKE_BINARY_DIR}/_deps")
            endif()
            
            if(DEFINED KIS_CURRENT_VARIANT_ABI_GROUP)
                string(TOLOWER "${KIS_CURRENT_VARIANT_ABI_GROUP}" _abi_lower)
                set(binary_dir "${FETCHCONTENT_BASE_DIR}/${_abi_lower}/${dep_name}-build")
            else()
                set(binary_dir "${FETCHCONTENT_BASE_DIR}/${dep_name}-build")
            endif()

            set(source_dir "${FETCHCONTENT_BASE_DIR}/${dep_name}-src")
            
            list(FIND dep_args "SOURCE_DIR" source_dir_idx)
            if(source_dir_idx GREATER -1)
                math(EXPR value_idx "${source_dir_idx} + 1")
                list(GET dep_args ${value_idx} source_dir)
            endif()
            list(FIND dep_args "BINARY_DIR" binary_dir_idx)
            if(binary_dir_idx GREATER -1)
                math(EXPR value_idx "${binary_dir_idx} + 1")
                list(GET dep_args ${value_idx} binary_dir)
            endif()
            
            get_property(is_populated GLOBAL PROPERTY _FetchContent_${dep_name}_populated)
            if(NOT is_populated AND EXISTS "${source_dir}/CMakeLists.txt")
                message(STATUS "  -> Reusing existing '${dep_name}' from ${source_dir}")
                add_subdirectory("${source_dir}" "${binary_dir}" EXCLUDE_FROM_ALL)
                set_property(GLOBAL PROPERTY _FetchContent_${dep_name}_populated TRUE)
                set_property(GLOBAL PROPERTY _FetchContent_${dep_name}_sourceDir "${source_dir}")
                set_property(GLOBAL PROPERTY _FetchContent_${dep_name}_binaryDir "${binary_dir}")
            elseif(is_populated)
                message(STATUS "  -> Dependency '${dep_name}' already loaded")
            else()
                message(WARNING "  -> Cannot reuse '${dep_name}': source dir missing or invalid")
                FetchContent_MakeAvailable(${dep_name})
            endif()
        endforeach()
    endif()
endfunction()

# ==============================================================================
#           STATISTICS AND UTILITIES
# ==============================================================================
function(kis_clear_dependency_cache)
    get_cmake_property(cache_vars CACHE_VARIABLES)
    set(cleared_count 0)
    foreach(var ${cache_vars})
        if(var MATCHES "^KIS_DEP_FINGERPRINT_")
            unset(${var} CACHE)
            math(EXPR cleared_count "${cleared_count} + 1")
        endif()
    endforeach()
    if(cleared_count GREATER 0)
        message(STATUS "[INCREMENTAL] Cleared ${cleared_count} cached dependency fingerprints")
    endif()
endfunction()

function(kis_show_dependency_cache)
    message(STATUS "\nCached Dependency Fingerprints:")
    message(STATUS "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
    get_cmake_property(cache_vars CACHE_VARIABLES)
    set(found_any FALSE)
    foreach(var ${cache_vars})
        if(var MATCHES "^KIS_DEP_FINGERPRINT_(.+)$")
            set(dep_name "${CMAKE_MATCH_1}")
            message(STATUS "  ${dep_name}:")
            message(STATUS "    ${${var}}")
            set(found_any TRUE)
        endif()
    endforeach()
    if(NOT found_any)
        message(STATUS "  (none cached yet)")
    endif()
    message(STATUS "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n")
endfunction()