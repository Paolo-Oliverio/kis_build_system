# cmake/build_system/dependency_resolution.cmake

function(kis_resolve_and_sync_packages)
    # Read KIS dependencies from the central state
    kis_state_get_kis_dependencies(all_kis_deps_json)
    if(NOT all_kis_deps_json)
        message(STATUS "No first-party package dependencies were declared by any package.")
        return()
    endif()
    list(REMOVE_DUPLICATES all_kis_deps_json)

    set(PACKAGES_ROOT "${CMAKE_CURRENT_SOURCE_DIR}/kis_packages")
    find_package(Git QUIET REQUIRED)

    set(known_remotes "")
    set(resolved_deps "")
    set(packages_on_disk "")

    while(TRUE)
        set(cloned_this_pass FALSE)

        kis_glob_package_directories("${PACKAGES_ROOT}" discovered_packages)
        set(packages_on_disk "")
        foreach(pkg_path ${discovered_packages})
            kis_get_package_name_from_path("${pkg_path}" pkg_name)
            list(APPEND packages_on_disk ${pkg_name})
        endforeach()
        
        set(resolved_deps "")
        set(known_remotes "")
        foreach(dep_json ${all_kis_deps_json})
            string(JSON dep_name GET "${dep_json}" "name")
            string(JSON dep_url GET "${dep_json}" "url")
            string(JSON dep_tag GET "${dep_json}" "tag")

            if(dep_name AND dep_url AND dep_tag)
                list(APPEND resolved_deps "${dep_name}")
                list(APPEND known_remotes "${dep_name};${dep_url};${dep_tag}")
            endif()
        endforeach()
        list(REMOVE_DUPLICATES resolved_deps)
        list(REMOVE_DUPLICATES known_remotes)

        set(packages_to_clone "")
        foreach(dep_name ${resolved_deps})
            if(NOT dep_name IN_LIST packages_on_disk)
                set(remote_found FALSE)
                foreach(remote_info ${known_remotes})
                    string(REPLACE ";" ";" remote_parts "${remote_info}")
                    list(GET remote_parts 0 remote_pkg_name)
                    if(remote_pkg_name STREQUAL dep_name)
                        list(GET remote_parts 1 pkg_url)
                        list(GET remote_parts 2 pkg_tag)
                        set(remote_found TRUE)
                        break()
                    endif()
                endforeach()

                if(NOT remote_found)
                    kis_message_fatal_actionable("Dependency Resolution Error" "Package '${dep_name}' has no remote location." "Ensure the package requiring it declares the url and tag.")
                endif()

                kis_is_url_trusted(is_trusted "${pkg_url}" "${KIS_TRUSTED_URL_PREFIXES}")
                if(NOT is_trusted)
                    kis_message_fatal_actionable("Security Error: Untrusted Package Source" "URL not trusted: ${pkg_url}" "Add prefix to KIS_TRUSTED_URL_PREFIXES in sdk_options.cmake.")
                endif()

                set(pkg_destination "${PACKAGES_ROOT}/${dep_name}")
                list(APPEND packages_to_clone "${dep_name}|||${pkg_url}|||${pkg_tag}|||${pkg_destination}")
            endif()
        endforeach()
        
        list(LENGTH packages_to_clone num_to_clone)
        if(num_to_clone GREATER 0)
            message(STATUS "Found ${num_to_clone} missing first-party packages to clone...")
            kis_parallel_clone_first_party(packages_to_clone)
            foreach(package_info ${packages_to_clone})
                string(REPLACE "|||" ";" package_info_list "${package_info}")
                list(GET package_info_list 0 dep_name)
                list(GET package_info_list 3 temp_destination)
                kis_get_package_platform_preference(platform_pref "${temp_destination}")
                if(platform_pref)
                    set(final_destination "${PACKAGES_ROOT}/${platform_pref}/${dep_name}")
                    if(NOT final_destination STREQUAL temp_destination)
                        message(STATUS "  -> Moving ${dep_name} to platform-specific location: ${platform_pref}/")
                        get_filename_component(final_dest_parent "${final_destination}" DIRECTORY)
                        file(MAKE_DIRECTORY "${final_dest_parent}")
                        file(RENAME "${temp_destination}" "${final_destination}")
                    endif()
                endif()
                set(cloned_this_pass TRUE)
                list(APPEND packages_on_disk ${dep_name})
            endforeach()
        endif()
        
        if(NOT cloned_this_pass)
            break()
        endif()
    endwhile()
    
    message(STATUS "First-party dependency resolution complete. All packages available.")
endfunction()