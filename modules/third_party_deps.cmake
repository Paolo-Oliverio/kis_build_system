# cmake/build_system/third_party_deps.cmake
#
# Provides functions for declaring, fetching, and building third-party
# dependencies using CMake's FetchContent module.

include(FetchContent)

#
# kis_handle_third_party_dependencies
#
# Parses third-party dependencies from a package manifest and registers them
# in the central state, performing version conflict detection.
#
function(kis_handle_third_party_dependencies _package_name _tpl_deps_json)
    if(NOT _tpl_deps_json)
        return()
    endif()

    string(JSON num_deps ERROR_VARIABLE err LENGTH "${_tpl_deps_json}")
    if(err OR num_deps EQUAL 0)
        return()
    endif()

    kis_state_get_tpl_dependencies(existing_deps)

    math(EXPR last_idx "${num_deps} - 1")
    foreach(i RANGE ${last_idx})
        string(JSON dep_obj GET "${_tpl_deps_json}" ${i})
        string(JSON dep_name ERROR_VARIABLE err GET "${dep_obj}" "name")
        if(err)
            kis_message_fatal_actionable("Malformed thirdParty Dependency" "Missing 'name' field." PACKAGE "${_package_name}")
            continue()
        endif()

        string(JSON dep_cond ERROR_VARIABLE err_cond GET "${dep_obj}" "condition")
        if(NOT err_cond AND DEFINED dep_cond AND NOT "${dep_cond}" STREQUAL "")
            if(NOT (DEFINED ${dep_cond} AND ${dep_cond}))
                message(STATUS "  -> Skipping optional dependency '${dep_name}' for '${_package_name}' (condition '${dep_cond}' is OFF)")
                continue()
            endif()
        endif()

        set(existing_dep_entry "")
        foreach(entry ${existing_deps})
            string(REPLACE "|||" ";" entry_parts "${entry}")
            list(GET entry_parts 0 entry_name)
            if(entry_name STREQUAL dep_name)
                set(existing_dep_entry "${entry}")
                break()
            endif()
        endforeach()

        string(JSON dep_tag ERROR_VARIABLE err_tag GET "${dep_obj}" "tag")
        if(err_tag) 
        unset(dep_tag)
        endif()
        
        if(existing_dep_entry)
            string(REPLACE "|||" ";" existing_parts "${existing_dep_entry}")
            list(GET existing_parts 2 existing_tag)
            list(GET existing_parts 5 existing_pkg) # Corrected index
            if(dep_tag AND existing_tag AND NOT dep_tag STREQUAL existing_tag)
                kis_message_fatal_actionable(
                    "Third-Party Dependency Version Conflict"
                    "Dependency '${dep_name}' has conflicting versions:\n"
                    "  - Package '${_package_name}' requires tag: '${dep_tag}'\n"
                    "  - Package '${existing_pkg}' requires tag: '${existing_tag}'"
                    "Please align the versions in the kis.package.json files."
                )
            endif()
        else()
            string(JSON dep_git ERROR_VARIABLE err_git GET "${dep_obj}" "git")
            if(err_git) 
            unset(dep_git)
            endif()
            string(JSON dep_url ERROR_VARIABLE err_url GET "${dep_obj}" "url")
            if(err_url)
            unset(dep_url)
            endif()
            string(JSON dep_hash ERROR_VARIABLE err_hash GET "${dep_obj}" "hash")
            if(err_hash)
            unset(dep_hash)
            endif()
            string(JSON dep_options_json ERROR_VARIABLE err_opts GET "${dep_obj}" "options")
            if(err_opts)
            unset(dep_options_json)
            endif()

            # Use a robust separator '|||'
            set(dep_struct "${dep_name}|||${dep_git}|||${dep_tag}|||${dep_url}|||${dep_hash}|||${_package_name}|||${dep_options_json}")
            # Add as a single, quoted item to the state list
            kis_state_add_tpl_dependency("${dep_struct}")
        endif()
    endforeach()
endfunction()

#
# kis_populate_declared_dependencies
#
function(kis_populate_declared_dependencies)
    kis_state_get_tpl_dependencies(declared_deps)
    if(NOT declared_deps)
        return()
    endif()

    kis_get_current_variant_name(current_variant)
    set(should_build_third_party FALSE)
    if(current_variant STREQUAL "release" OR current_variant STREQUAL "debug")
        set(should_build_third_party TRUE)
        message(STATUS "Building third-party dependencies for '${current_variant}' variant")
    else()
        message(STATUS "Skipping third-party dependency builds for '${current_variant}' variant (will reuse from base)")
    endif()

    set(dep_names_to_fetch "")
    
    if(should_build_third_party)
        foreach(dep_entry ${declared_deps})
            string(REPLACE "|||" ";" dep_parts "${dep_entry}")
            list(GET dep_parts 0 dep_name)
            list(GET dep_parts 6 options_json) # Corrected index
            
            if(options_json)
                string(JSON num_opts ERROR_VARIABLE err LENGTH "${options_json}")
                if(NOT err AND num_opts GREATER 0)
                    math(EXPR last_idx "${num_opts} - 1")
                    foreach(i RANGE ${last_idx})
                        string(JSON opt_obj GET "${options_json}" ${i})
                        string(JSON opt_name GET "${opt_obj}" "name")
                        string(JSON opt_val GET "${opt_obj}" "value")
                        string(JSON opt_type GET "${opt_obj}" "type")
                        string(JSON opt_cond ERROR_VARIABLE cond_err GET "${opt_obj}" "condition")
                        if(cond_err)
                        unset(opt_cond)
                        endif()

                        set(condition_met TRUE)
                        if(DEFINED opt_cond AND NOT "${opt_cond}" STREQUAL "")
                            if(NOT ${opt_cond}) 
                            set(condition_met FALSE)
                            endif()
                        endif()

                        if(condition_met)
                            message(STATUS "  -> Applying option for ${dep_name}: ${opt_name}=${opt_val}")
                            set(${opt_name} "${opt_val}" CACHE ${opt_type} "Option for dependency ${dep_name}" FORCE)
                        endif()
                    endforeach()
                endif()
            endif()
        endforeach()
    endif()

    if(should_build_third_party)
        foreach(dep_entry ${declared_deps})
            string(REPLACE "|||" ";" dep_parts "${dep_entry}")
            # Safely get parts, checking length
            list(LENGTH dep_parts num_parts)
            if(num_parts LESS 7)
                message(WARNING "Skipping malformed dependency entry: ${dep_entry}")
                continue()
            endif()
            list(GET dep_parts 0 dep_name)
            list(GET dep_parts 1 git_repo)
            list(GET dep_parts 2 git_tag)
            list(GET dep_parts 3 url)
            list(GET dep_parts 4 url_hash)

            set(dep_args "")
            if(git_repo) 
            list(APPEND dep_args GIT_REPOSITORY "${git_repo}")
            endif()
            if(git_tag)
            list(APPEND dep_args GIT_TAG "${git_tag}") 
            endif()
            if(url)
            list(APPEND dep_args URL "${url}")
            endif()
            if(url_hash)
            list(APPEND dep_args URL_HASH "${url_hash}")
            endif()
            
            # Store dependency arguments in a CACHE variable instead of GLOBAL PROPERTY
            set(_KIS_CTX_TPL_DECLARED_${dep_name}_ARGS ${dep_args} CACHE INTERNAL "Args for TPL dependency" FORCE)
            FetchContent_Declare(${dep_name} ${dep_args})
            list(APPEND dep_names_to_fetch ${dep_name})
        endforeach()

        if(dep_names_to_fetch)
            list(REMOVE_DUPLICATES dep_names_to_fetch)
            if(KIS_ENABLE_INCREMENTAL_DEPENDENCIES)
                kis_fetch_content_make_available_incremental("${dep_names_to_fetch}")
            else()
                FetchContent_MakeAvailable(${dep_names_to_fetch})
            endif()
            kis_detect_self_installing_dependencies("${dep_names_to_fetch}")
        endif()
    else()
        # This logic handles reusing pre-built dependencies and doesn't need to set options.
        if(KIS_CURRENT_VARIANT_ABI_GROUP STREQUAL "RELEASE")
            set(base_binary_dir "${CMAKE_BINARY_DIR}/../release/_deps")
            set(base_variant "release")
        else()
            set(base_binary_dir "${CMAKE_BINARY_DIR}/../debug/_deps")
            set(base_variant "debug")
        endif()
        
        message(STATUS "Looking for pre-built third-party dependencies in ${base_variant} build...")
        
        kis_state_get_tpl_dependency_names(dep_names)
        foreach(dep_name ${dep_names})
            # Retrieve dependency arguments from CACHE
            set(dep_args "${_KIS_CTX_TPL_DECLARED_${dep_name}_ARGS}")
            list(FIND dep_args "SOURCE_DIR" source_dir_idx)
            if(source_dir_idx GREATER -1)
                math(EXPR value_idx "${source_dir_idx} + 1")
                list(GET dep_args ${value_idx} source_dir)
            else()
                set(source_dir "${FETCHCONTENT_BASE_DIR}/${dep_name}-src")
            endif()
            
            set(base_build_dir "${base_binary_dir}/${dep_name}-build")
            set(base_source_dir_from_cache "${FETCHCONTENT_BASE_DIR}/${dep_name}-src")
            set(is_header_only FALSE)
            if(NOT EXISTS "${base_build_dir}" AND EXISTS "${base_source_dir_from_cache}")
                set(is_header_only TRUE)
            endif()
            
            if(EXISTS "${base_build_dir}" OR is_header_only)
                if(is_header_only)
                    message(STATUS "  -> Reusing ${dep_name} from ${base_variant} (header-only)")
                else()
                    message(STATUS "  -> Reusing ${dep_name} from ${base_variant} build")
                endif()
                
                FetchContent_Declare(${dep_name} ${dep_args})
                FetchContent_GetProperties(${dep_name})
                if(NOT ${dep_name}_POPULATED)
                    if(is_header_only)
                        set(${dep_name}_SOURCE_DIR "${base_source_dir_from_cache}")
                        set(${dep_name}_BINARY_DIR "${CMAKE_CURRENT_BINARY_DIR}/_deps/${dep_name}-build")
                        add_subdirectory("${base_source_dir_from_cache}" "${${dep_name}_BINARY_DIR}" EXCLUDE_FROM_ALL)
                    else()
                        set(${dep_name}_BINARY_DIR "${base_build_dir}")
                        set(${dep_name}_SOURCE_DIR "${source_dir}")
                        set(config_loaded FALSE)
                        if(EXISTS "${base_build_dir}/${dep_name}Config.cmake")
                            include("${base_build_dir}/${dep_name}Config.cmake")
                            set(config_loaded TRUE)
                        elseif(EXISTS "${base_build_dir}/${dep_name}-config.cmake")
                            include("${base_build_dir}/${dep_name}-config.cmake")
                            set(config_loaded TRUE)
                        elseif(EXISTS "${base_build_dir}/cmake/${dep_name}Config.cmake")
                            include("${base_build_dir}/cmake/${dep_name}Config.cmake")
                            set(config_loaded TRUE)
                        endif()
                        if(NOT config_loaded)
                            message(STATUS "    No config file found, attempting manual import...")
                            kis_glob_library_files("${base_build_dir}" lib_files)
                            if(lib_files)
                                if(NOT TARGET ${dep_name})
                                    add_library(${dep_name} STATIC IMPORTED GLOBAL)
                                    list(GET lib_files 0 first_lib_file)
                                    set_target_properties(${dep_name} PROPERTIES IMPORTED_LOCATION "${first_lib_file}")
                                    if(EXISTS "${source_dir}/include")
                                        target_include_directories(${dep_name} INTERFACE "${source_dir}/include")
                                    endif()
                                    message(STATUS "    Created imported target: ${dep_name} -> ${first_lib_file}")
                                endif()
                            else()
                                kis_collect_warning("Could not find library files for ${dep_name} in ${base_build_dir} - falling back to add_subdirectory (may cause rebuild)")
                                add_subdirectory("${source_dir}" "${base_build_dir}" EXCLUDE_FROM_ALL)
                            endif()
                        endif()
                    endif()
                    set(${dep_name}_POPULATED TRUE)
                endif()
            else()
                kis_collect_warning("Third-party dependency '${dep_name}' not found in ${base_variant} build! Expected: ${base_build_dir}")
                message(FATAL_ERROR "Missing third-party dependency '${dep_name}'. Please build the '${base_variant}' variant first before building '${current_variant}'")
            endif()
        endforeach()
    endif()
endfunction()

function(kis_detect_self_installing_dependencies DEP_NAMES)
    message(STATUS "Analyzing third-party installation strategies...")
    foreach(dep_name ${DEP_NAMES})
        FetchContent_GetProperties(${dep_name})
        string(TOLOWER ${dep_name} dep_name_lower)
        set(_dep_source_dir "${${dep_name_lower}_SOURCE_DIR}")
        set(should_self_install FALSE)
        if(_dep_source_dir AND EXISTS "${_dep_source_dir}/CMakeLists.txt")
            file(READ "${_dep_source_dir}/CMakeLists.txt" _cmake_content)
            if(_cmake_content MATCHES "install\\s*\\(\\s*EXPORT")
                set(should_self_install TRUE)
            endif()
        endif()
        if(should_self_install)
            kis_state_add_self_installing_dep(${dep_name})
            message(STATUS "  - ${dep_name}: Self-installing (will use its own install rules)")
        else()
            message(STATUS "  - ${dep_name}: SDK-managed (no install(EXPORT) found)")
        endif()
    endforeach()
endfunction()